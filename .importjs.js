// @flow

const { startsWith } = require("lodash/fp");

const { dirname, relative } = require("path");

module.exports = {
  minimumVersion: "2.10.0",
  useRelativePaths: false,

  environments: ["node", "jest"],
  declarationKeyword: "import", // Node environment changed the default value

  importStatementFormatter({ importStatement }) {
    // Use double quotes
    return importStatement.replace(/'/g, '"');
  },

  moduleNameFormatter(conf) {
    function isRelative(currentDir, importFile) {
      const parentDir = dirname(currentDir);
      return startsWith(parentDir, importFile);
    }

    function buildRelative(currentDir, importFile) {
      const path = relative(currentDir, importFile);
      const mod = path.replace(/\.[^.]+$/, "");
      return startsWith("..", mod) ? mod : "./" + mod;
    }

    const {
      pathToCurrentFile: currentFile,
      pathToImportedModule: importFile,
      moduleName
    } = conf;
    const currentDir = dirname(currentFile);
    return isRelative(currentDir, importFile)
      ? buildRelative(currentDir, importFile)
      : startsWith("./src/", currentDir) && startsWith("./", importFile)
      ? moduleName.replace(/^src/, "")
      : moduleName;
  },

  namedExports: {
    "lodash/fp": [
      // v4.17.5
      "chunk",
      "compact",
      "concat",
      "difference",
      "differenceBy",
      "differenceWith",
      "drop",
      "dropRight",
      "dropRightWhile",
      "dropWhile",
      "fill",
      "findIndex",
      "findLastIndex",
      "head",
      "flatten",
      "flattenDeep",
      "flattenDepth",
      "fromPairs",
      "indexOf",
      "initial",
      "intersection",
      "intersectionBy",
      "intersectionWith",
      "join",
      "last",
      "lastIndexOf",
      "nth",
      "pull",
      "pullAll",
      "pullAllBy",
      "pullAllWith",
      "pullAt",
      "remove",
      "reverse",
      "slice",
      "sortedIndex",
      "sortedIndexBy",
      "sortedIndexOf",
      "sortedLastIndex",
      "sortedLastIndexBy",
      "sortedLastIndexOf",
      "sortedUniq",
      "sortedUniqBy",
      "tail",
      "take",
      "takeRight",
      "takeRightWhile",
      "takeWhile",
      "union",
      "unionBy",
      "unionWith",
      "uniq",
      "uniqBy",
      "uniqWith",
      "unzip",
      "unzipWith",
      "xor",
      "xorBy",
      "xorWith",
      "zip",
      "zipObject",
      "zipObjectDeep",
      "zipWith",
      "countBy",
      "each",
      "forEach",
      "eachRight",
      "forEachRight",
      "every",
      "filter",
      "find",
      "findLast",
      "flatMap",
      "flatMapDeep",
      "flatMapDepth",
      "groupBy",
      "includes",
      "invokeMap",
      "keyBy",
      "map",
      "orderBy",
      "partition",
      "reduce",
      "reduceRight",
      "reject",
      "sample",
      "sampleSize",
      "shuffle",
      "size",
      "some",
      "sortBy",
      "now",
      "after",
      "ary",
      "before",
      "bind",
      "bindKey",
      "curry",
      "curryRight",
      "debounce",
      "defer",
      "delay",
      "flip",
      "memoize",
      "negate",
      "once",
      "overArgs",
      "partial",
      "partialRight",
      "rearg",
      "rest",
      "spread",
      "throttle",
      "unary",
      "wrap",
      "castArray",
      "clone",
      "cloneDeep",
      "cloneDeepWith",
      "cloneWith",
      "conformsTo",
      "eq",
      "gt",
      "gte",
      "isArguments",
      "isArray",
      "isArrayBuffer",
      "isArrayLike",
      "isArrayLikeObject",
      "isBoolean",
      "isBuffer",
      "isDate",
      "isElement",
      "isEmpty",
      "isEqual",
      "isEqualWith",
      "isError",
      "isFinite",
      "isFunction",
      "isInteger",
      "isLength",
      "isMap",
      "isMatch",
      "isMatchWith",
      "isNaN",
      "isNative",
      "isNil",
      "isNull",
      "isNumber",
      "isObject",
      "isObjectLike",
      "isPlainObject",
      "isRegExp",
      "isSafeInteger",
      "isSet",
      "isString",
      "isSymbol",
      "isTypedArray",
      "isUndefined",
      "isWeakMap",
      "isWeakSet",
      "lt",
      "lte",
      "toArray",
      "toFinite",
      "toInteger",
      "toLength",
      "toNumber",
      "toPlainObject",
      "toSafeInteger",
      "toString",
      "add",
      "ceil",
      "divide",
      "floor",
      "max",
      "maxBy",
      "mean",
      "meanBy",
      "min",
      "minBy",
      "multiply",
      "round",
      "subtract",
      "sum",
      "sumBy",
      "clamp",
      "inRange",
      "random",
      "assign",
      "assignIn",
      "assignInWith",
      "assignWith",
      "at",
      "create",
      "defaults",
      "defaultsDeep",
      "findKey",
      "findLastKey",
      "forIn",
      "forInRight",
      "forOwn",
      "forOwnRight",
      "functions",
      "functionsIn",
      "get",
      "has",
      "hasIn",
      "invert",
      "invertBy",
      "invoke",
      "keys",
      "keysIn",
      "mapKeys",
      "mapValues",
      "merge",
      "mergeWith",
      "omit",
      "omitBy",
      "pick",
      "pickBy",
      "result",
      "set",
      "setWith",
      "toPairs",
      "toPairsIn",
      "transform",
      "unset",
      "update",
      "updateWith",
      "values",
      "valuesIn",
      "tap",
      "thru",
      "camelCase",
      "capitalize",
      "deburr",
      "endsWith",
      "escape",
      "escapeRegExp",
      "kebabCase",
      "lowerCase",
      "lowerFirst",
      "pad",
      "padEnd",
      "padStart",
      "parseInt",
      "repeat",
      "replace",
      "snakeCase",
      "split",
      "startCase",
      "startsWith",
      "template",
      "toLower",
      "toUpper",
      "trim",
      "trimEnd",
      "trimStart",
      "truncate",
      "unescape",
      "upperCase",
      "upperFirst",
      "words",
      "attempt",
      "bindAll",
      "cond",
      "conforms",
      "constant",
      "defaultTo",
      "flow",
      "flowRight",
      "identity",
      "iteratee",
      "matches",
      "matchesProperty",
      "method",
      "methodOf",
      "mixin",
      "noConflict",
      "noop",
      "nthArg",
      "over",
      "overEvery",
      "overSome",
      "propertyOf",
      "range",
      "rangeRight",
      "runInContext",
      "stubArray",
      "stubFalse",
      "stubObject",
      "stubString",
      "stubTrue",
      "times",
      "toPath",
      "uniqueId",
      "VERSION",
      //"F",
      //"T", <- conflict with flow generics
      "__",
      "all",
      "allPass",
      "always",
      "any",
      "anyPass",
      "apply",
      "assoc",
      "assocPath",
      "complement",
      "compose",
      "contains",
      "dissoc",
      "dissocPath",
      "dropLast",
      "dropLastWhile",
      "entries",
      "entriesIn",
      "equals",
      "extend",
      "extendAll",
      "extendAllWith",
      "extendWith",
      "first",
      "identical",
      "indexBy",
      "init",
      "invertObj",
      "juxt",
      "nAry",
      "omitAll",
      "path",
      "pathEq",
      "pathOr",
      "paths",
      "pickAll",
      "pipe",
      "pluck",
      "prop",
      "propEq",
      "propOr",
      "property",
      "props",
      "symmetricDifference",
      "symmetricDifferenceBy",
      "symmetricDifferenceWith",
      "takeLast",
      "takeLastWhile",
      "unapply",
      "unnest",
      "useWith",
      "without",
      "where",
      "whereEq",
      "zipObj",
      "assignAll",
      "assignAllWith",
      "assignInAll",
      "assignInAllWith",
      "curryN",
      "curryRightN",
      "defaultsAll",
      "defaultsDeepAll",
      "findFrom",
      "findIndexFrom",
      "findLastFrom",
      "findLastIndexFrom",
      "getOr",
      "includesFrom",
      "indexOfFrom",
      "invokeArgs",
      "invokeArgsMap",
      "lastIndexOfFrom",
      "mergeAll",
      "mergeAllWith",
      "padChars",
      "padCharsEnd",
      "padCharsStart",
      "rangeStep",
      "rangeStepRight",
      "restFrom",
      "spreadFrom",
      "trimChars",
      "trimCharsEnd",
      "trimCharsStart",
      "zipAll"
    ]
  }
};
